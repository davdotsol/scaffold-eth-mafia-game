{
  "language": "Solidity",
  "sources": {
    "contracts/MafiaGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MafiaGame {\n\tenum Role {\n\t\tNone,\n\t\tMafia,\n\t\tDoctor,\n\t\tDetective,\n\t\tTownsperson\n\t}\n\n\tstruct Player {\n\t\taddress addr;\n\t\tRole role;\n\t\tbool alive;\n\t}\n\n\tenum Phase {\n\t\tDay,\n\t\tNight\n\t}\n\n\tuint public playerCount;\n\tuint public mafiaCount;\n\tuint public phaseStartTime;\n\tuint public cycleCount; // Added to count the number of cycles\n\tPhase public currentPhase;\n\tmapping(address => Player) public players;\n\tmapping(address => address) public accusations;\n\tmapping(address => uint) public votes;\n\tmapping(address => bool) public hasVoted;\n\tmapping(address => string[]) public accusationReasons; // New mapping to store reasons\n\taddress[] public accusedPlayers;\n\taddress[] public playerAddresses;\n\taddress[] public mafiaAddresses;\n\taddress[] public eliminatedAddresses;\n\taddress public mayor;\n\taddress public target;\n\taddress public saved;\n\taddress public investigated;\n\tstring public story;\n\tbool public gameStarted;\n\tbool public votingCompleted;\n\tuint public votesCast;\n\taddress public playerToEliminate;\n\tuint public accusationsCount;\n\n\tmodifier onlyMayor() {\n\t\trequire(msg.sender == mayor, \"Only the mayor can perform this action\");\n\t\t_;\n\t}\n\n\tmodifier onlyAlive() {\n\t\trequire(\n\t\t\tplayers[msg.sender].alive,\n\t\t\t\"You are dead and cannot perform this action\"\n\t\t);\n\t\t_;\n\t}\n\n\tevent PlayerJoined(Player player);\n\tevent RoleAssigned(address indexed player, Role role);\n\tevent PhaseChanged(Phase newPhase, string story);\n\tevent PlayerAccused(address indexed accuser, address indexed accused);\n\tevent VoteCast(address indexed voter, address indexed accused);\n\tevent VotingCompleted(address indexed eliminatedPlayer);\n\tevent PlayerEliminated(address indexed eliminatedPlayer);\n\tevent GameWon(string message);\n\tevent GameContinue();\n\tevent AccusationCompleted();\n\n\tconstructor() {\n\t\tmayor = msg.sender;\n\t\tcurrentPhase = Phase.Night;\n\t\tphaseStartTime = block.timestamp;\n\t\tcycleCount = 0; // Initialize cycleCount\n\t}\n\n\tfunction joinGame() public {\n\t\trequire(!gameStarted, \"The game has already started\");\n\t\trequire(\n\t\t\tplayers[msg.sender].addr == address(0),\n\t\t\t\"Player already joined\"\n\t\t);\n\n\t\tplayers[msg.sender] = Player({\n\t\t\taddr: msg.sender,\n\t\t\trole: Role.None,\n\t\t\talive: true\n\t\t});\n\n\t\tplayerAddresses.push(msg.sender);\n\t\tplayerCount++;\n\t\temit PlayerJoined(players[msg.sender]);\n\t}\n\n\tfunction startGame() public onlyMayor {\n\t\trequire(\n\t\t\tplayerCount >= 4,\n\t\t\t\"Minimum 4 players required to start the game\"\n\t\t);\n\t\trequire(!gameStarted, \"The game has already started\");\n\n\t\tgameStarted = true;\n\t\tuint mafiaNum = playerCount / 4;\n\t\tmafiaCount = mafiaNum;\n\n\t\t// Shuffle players for random role assignment\n\t\tfor (uint i = 0; i < playerCount; i++) {\n\t\t\tuint randomIndex = i +\n\t\t\t\t(uint(\n\t\t\t\t\tkeccak256(\n\t\t\t\t\t\tabi.encodePacked(block.timestamp, block.difficulty)\n\t\t\t\t\t)\n\t\t\t\t) % (playerCount - i));\n\t\t\taddress temp = playerAddresses[i];\n\t\t\tplayerAddresses[i] = playerAddresses[randomIndex];\n\t\t\tplayerAddresses[randomIndex] = temp;\n\t\t}\n\n\t\t// Assign roles\n\t\tfor (uint i = 0; i < playerCount; i++) {\n\t\t\tif (i < mafiaNum) {\n\t\t\t\tplayers[playerAddresses[i]].role = Role.Mafia;\n\t\t\t\tmafiaAddresses.push(playerAddresses[i]);\n\t\t\t} else if (i == mafiaNum) {\n\t\t\t\tplayers[playerAddresses[i]].role = Role.Doctor;\n\t\t\t} else if (i == mafiaNum + 1) {\n\t\t\t\tplayers[playerAddresses[i]].role = Role.Detective;\n\t\t\t} else {\n\t\t\t\tplayers[playerAddresses[i]].role = Role.Townsperson;\n\t\t\t}\n\t\t\temit RoleAssigned(\n\t\t\t\tplayerAddresses[i],\n\t\t\t\tplayers[playerAddresses[i]].role\n\t\t\t);\n\t\t}\n\n\t\tphaseStartTime = block.timestamp;\n\t}\n\n\tfunction nextPhase() public onlyMayor {\n\t\trequire(gameStarted, \"The game has not started yet\");\n\n\t\tif (currentPhase == Phase.Night) {\n\t\t\tcurrentPhase = Phase.Day;\n\t\t} else {\n\t\t\tcurrentPhase = Phase.Night;\n\t\t\tresetAccusationsAndVotes();\n\t\t\tresetVotingStatus(); // Reset voting status for the new phase\n\t\t}\n\t\tphaseStartTime = block.timestamp;\n\t\tcycleCount++; // Increment cycleCount on each phase change\n\t\ttarget = address(0);\n\t\tsaved = address(0);\n\t\tinvestigated = address(0);\n\t\tvotesCast = 0; // Reset the vote count\n\t\taccusationsCount = 0; // Reset the accusations count\n\t\temit PhaseChanged(currentPhase, story);\n\t}\n\n\tfunction resetVotingStatus() internal {\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\n\t\t\thasVoted[playerAddresses[i]] = false; // Reset the hasVoted status\n\t\t}\n\t}\n\n\tfunction resetAccusationsAndVotes() internal {\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\n\t\t\taccusations[playerAddresses[i]] = address(0);\n\t\t\tvotes[playerAddresses[i]] = 0; // Reset the votes\n\t\t}\n\t\tdelete accusedPlayers;\n\t}\n\n\tfunction accusePlayer(\n\t\taddress _accused,\n\t\tstring memory _reason\n\t) public onlyAlive {\n\t\trequire(currentPhase == Phase.Day, \"Can only accuse during day phase\");\n\t\trequire(\n\t\t\taccusations[msg.sender] == address(0),\n\t\t\t\"You have already accused a player\"\n\t\t);\n\n\t\taccusations[msg.sender] = _accused;\n\t\taccusationReasons[_accused].push(_reason); // Store the reason\n\t\taccusedPlayers.push(_accused);\n\t\taccusationsCount++;\n\t\temit PlayerAccused(msg.sender, _accused);\n\n\t\tif (accusationsCount == playerCount) {\n\t\t\temit AccusationCompleted();\n\t\t}\n\t}\n\n\tfunction getAccusationReasons(\n\t\taddress _accused\n\t) public view returns (string[] memory) {\n\t\treturn accusationReasons[_accused];\n\t}\n\n\tfunction voteForElimination(address _accused) public onlyAlive {\n\t\trequire(currentPhase == Phase.Day, \"Can only vote during day phase\");\n\t\trequire(\n\t\t\taccusations[_accused] != address(0),\n\t\t\t\"Player must be accused first\"\n\t\t);\n\t\trequire(!hasVoted[msg.sender], \"You have already voted\"); // Ensure player hasn't voted\n\n\t\tvotes[_accused]++;\n\t\tvotesCast++; // Increase the number of votes cast\n\t\thasVoted[msg.sender] = true; // Mark the player as having voted\n\t\temit VoteCast(msg.sender, _accused);\n\n\t\tif (votesCast == playerCount) {\n\t\t\t// Check if all players have voted\n\t\t\taddress eliminatedPlayer = determineEliminatedPlayer();\n\t\t\tplayerToEliminate = eliminatedPlayer;\n\t\t\tvotingCompleted = true;\n\t\t\temit VotingCompleted(eliminatedPlayer);\n\t\t}\n\t}\n\n\tfunction determineEliminatedPlayer() internal view returns (address) {\n\t\taddress eliminatedPlayer;\n\t\tuint highestVotes = 0;\n\t\tfor (uint i = 0; i < accusedPlayers.length; i++) {\n\t\t\tif (votes[accusedPlayers[i]] > highestVotes) {\n\t\t\t\thighestVotes = votes[accusedPlayers[i]];\n\t\t\t\teliminatedPlayer = accusedPlayers[i];\n\t\t\t}\n\t\t}\n\t\treturn eliminatedPlayer;\n\t}\n\n\tfunction eliminatePlayer() public onlyMayor {\n\t\trequire(playerToEliminate != address(0), \"Eliminated must be a player\");\n\t\tplayers[playerToEliminate].alive = false;\n\t\tplayerCount--;\n\t\temit PlayerEliminated(playerToEliminate);\n\t}\n\n\tfunction checkWin() public {\n\t\tuint aliveMafia = 0;\n\t\tuint aliveTownspeople = 0;\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\n\t\t\tif (players[playerAddresses[i]].alive) {\n\t\t\t\tif (players[playerAddresses[i]].role == Role.Mafia) {\n\t\t\t\t\taliveMafia++;\n\t\t\t\t} else {\n\t\t\t\t\taliveTownspeople++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (aliveMafia == 0) {\n\t\t\temit GameWon(\"Townspeople win!\");\n\t\t} else if (aliveMafia >= aliveTownspeople) {\n\t\t\temit GameWon(\"Mafia wins!\");\n\t\t} else {\n\t\t\temit GameContinue();\n\t\t}\n\t}\n\n\tfunction resetGame() private onlyMayor {\n\t\tfor (uint i = 0; i < playerAddresses.length; i++) {\n\t\t\tdelete players[playerAddresses[i]];\n\t\t\tdelete accusations[playerAddresses[i]];\n\t\t\tdelete votes[playerAddresses[i]];\n\t\t}\n\t\tdelete playerAddresses;\n\t\tdelete accusedPlayers;\n\t\tdelete mafiaAddresses;\n\n\t\tplayerCount = 0;\n\t\tmafiaCount = 0;\n\t\tphaseStartTime = block.timestamp;\n\t\tcurrentPhase = Phase.Night;\n\t\tgameStarted = false;\n\t\tvotingCompleted = false;\n\t\tvotesCast = 0;\n\t\taccusationsCount = 0;\n\t\tplayerToEliminate = address(0);\n\t\ttarget = address(0);\n\t\tsaved = address(0);\n\t\tinvestigated = address(0);\n\t\tstory = \"\";\n\t\tcycleCount = 0; // Reset cycleCount on game reset\n\n\t\temit PhaseChanged(currentPhase, story);\n\t}\n\n\tfunction getPlayers() public view returns (address[] memory) {\n\t\treturn playerAddresses;\n\t}\n\n\tfunction getAccusedPlayers() public view returns (address[] memory) {\n\t\treturn accusedPlayers;\n\t}\n\n\tfunction getEliminatedPlayers() public view returns (address[] memory) {\n\t\treturn eliminatedAddresses;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}